---
title: "Infer temporal cell-cell communication change in spatial at single-cell level with RNA velocity information associated"
author: "Jialin Liu, Yichen Wang"
date: "2024-01-03"
output: 
  html_document:
    toc: true
    toc_float:
      toc_collapsed: false
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{Infer temporal cell-cell communication change in spatial at single-cell level with RNA velocity information}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

## Introduction

CytoSignal detects cell-cell signaling from spatial transcriptomics data at single-cell resolution. CytoSignal performs a nonparametric statistical test to identify which cells within a tissue have significant activity for a particular signaling interaction. CytoSignal considers multi-component interactions and separately models interactions mediated by diffusion vs. contact-dependent molecules.

**We have introduced the [basic CytoSignal workflow](#) in detail.** This vignette extends the analysis to inferring temporal changes in signaling strength. The signaling interaction strength changes when either the ligand or receptor expression changes. Previous work has shown that spliced and unspliced counts can be used to estimate the time derivative of a geneâ€™s expression, a concept called RNA velocity. ([Gioele La Manno et al., 2018](https://doi.org/10.1038/s41586-018-0414-6)) These velocity estimates of the rate of change for ligand and receptor expression can then be used to predict whether a particular signaling interaction will increase or decrease in strength over time.

## Example data

For this tutorial, we use a cortex dataset **TODO: with some more biology and sequencing technology context**. We have derived the necessary information for inferring the temporal signaling change, including the spliced ($s$) and unspliced ($u$) RNA velocity. These two matrices are required for temporal singling change inference. In this example, the $s$ and $u$ matrices are derived with [VeloVAE]() using its full VB model with default hyperparameters. Other RNA velocity inference tools, such as [scvelo](), can all produce the two matrices with desired format (i.e. dense matrix in gene x cell dimensionality), as this is the standard representation of RNA velocity inference result. 

We have already performed [regular CytoSignal analysis]() following the other vignette. Please refer to the other vignette for detailed walk-through. Here we provide the processed CytoSignal object and move on to the analysis with VeloCytoSignal.

- CytoSignal object with regular CytoSignal analysis performed: [cortex-something_vcs-obj.rds](https://...)
- $s$ matrix that stands for the spliced RNA velocity inference from the dataset: [cortex-something_velo-spliced.rds](https://...)
- $u$ matrix that stands for the unspliced RNA velocity inference from the dataset: [cortex-something_velo-unspliced.rds](https://...)

Download the files listed above from the provided link into a desired local directory. The code chunks below assumes that users have the files placed at the current working directory (as can be shown by `getwd()`). Then load the data into R environment. 

```{r load}
library(cytosignal)

vcs <- readRDS("cortex-fullvb-adult_vcs-obj.rds")
velo.s <- readRDS("cortex-fullvb-adult_velo-spliced.rds")
velo.u <- readRDS("cortex-fullvb-adult_velo-unspliced.rds")
```

In order to get started with VeloCytoSignal analysis, we simply need to add the spliced and unspliced velocity matrices into the object so that the analytic functions will be able to make use of them automatically. 

```{r addVelo}
vcs <- addVelo(vcs, velo.s = velo.s, velo.u = velo.u)
```

## Imputation

Similar to a regular CytoSignal workflow, we impute the L and R changes from nearest neighbors using different strategies for diffusion-dependent and contact-dependent interactions. There is no need to do the neighbor finding here because it is already done during the regular workflow. Here, we implemented `imputeNicheVelo()` method to pull the RNA velocity from the nearest neighbors of each location and impute the temporal ligand/receptor change.

```{r impute}
# Impute value for diffusion-dependent ligands
vcs <- imputeNicheVelo(vcs, nn.type = "GauEps")
# Impute value for contact-dependent ligands
vcs <- imputeNicheVelo(vcs, nn.type = "DT")
# Impute value for receptors
vcs <- imputeNicheVelo(vcs, nn.type = "Raw")
```

## Calculating velo LR Scores

Recall that in a regular inference, we calculate LR score, which is defined for each cell location and measures the signaling interaction strength. In VeloCytoSignal, with the imputed temporal change of ligands and receptors, we can calculate the veloLR score which measures the time derivative of the signaling strength. This is the primary result of VeloCytoSignal analysis.

```{r veloLR}
vcs <- inferVeloLR(vcs, lig.slot = "GauEps", recep.slot = "Raw", intr.db.name = "diff_dep")
vcs <- inferVeloLR(vcs, lig.slot = "DT", recep.slot = "Raw", intr.db.name = "cont_dep")
```

To access the exact value for the veloLR scores, users can explore the object with the following command with replacing `<nn.type>` by strings `"GauEps-Raw"` for diffusion-dependent interactions, or `"DT-Raw"` for contact-dependent interactions. The returned result is a sparse matrix with barcodes on rows and interaction ID on columns and values indicating the temporal interaction signaling strength change for each interaction in each cell.

```{r veloLRRes, eval=FALSE}
vcs@lrvelo[[<nn.type>]]@intr.velo
```

## Visualizing individual interactions

With all the necessary inference performed, now we show the visualization methods for exploring and understanding the analysis. This part shows visualization methods that applies to individual interactions.

Most of the functions shown here understand the interaction specification with two arguments: `intr` and `slot.use`. Users can first show a list of significant interactions that is available for visualization with `showIntr()`.

```{r showIntr, results=TRUE}
# Show significant diffusible interaction IDs associated with interaction names
showIntr(vcs, slot.use = "GauEps-Raw", return.name = TRUE)
```

Using `return.name = TRUE` here allows showing the unique IDs and interaction name, in a form of "ligand-receptor", at the same time, so things can be more interpretable. Note that, the list of available interactions varies for different LRscore inferences. For listing significant interactions with diffusible ligands, most of the time we have `slot.use = "GauEps-Raw"` if users did the LRscore inference with default setting. Similarly, for finding the significant contact dependent interactions, we need to set `slot.use = "DT-Raw"` if everything above went with default. 

In the plotting functions we show next, users need to specify the unique ID(s) of interests and the LRscore slot, where the interaction is found, at the same time. This is for ensuring that the correct result is captured when multiple inferences with parameter tweaks are performed for the same type of interactions.

### Significance plot

We provide function `plotSignif2()` for making a general combination figure that shows the imputed expression values of the ligand and receptor, the original raw expression values of the ligand and receptor, the inferred LRscore of an interaction of interests, and a cluster label plot. General graphical setting can be found in the documentation of the function (`?plotSignif2`). 

```{r signif, fig.width=9, fig.height=6}
plotSignif2(cs, intr = "CPI-SS0D5E30C6C", slot.use = "GauEps-Raw", return.plot = TRUE)
```

**Recommended:** In a more exploratory scenario, users can also do using numeric index with `intr` and turn to `return.plot = FALSE` (default). This way, a bunch of significance plot of high resolution can be stored on device and be browsed more easily. We also recommend doing this for both contact-dependent interactions and diffusion-dependent interactions.

```{r plotsignif2, eval=FALSE}
# For diffusion dependent interactions
## Choose a level of significance metric
signif.use <- "result.hq.corr"
lrscore.slot <- "GauEps-Raw"
plot_dir <- paste0("path_to_result/diff-dep_", signif.use, "_", lrscore.slot, "/")
plotSignif2(cs, intr = 1:5, slot.use = lrscore.slot, signif.use = signif.use, plot_dir = plot_dir)

# For contact dependent interactions
## Choose a level of significance metric
signif.use <- "result.hq.corr"
lrscore.slot <- "DT-Raw"
plot_dir <- paste0("path_to_result/cont-dep_", signif.use, "_", lrscore.slot, "/")
plotSignif2(cs, intr = 1:5, slot.use = lrscore.slot, signif.use = signif.use, plot_dir = plot_dir)
```


### Edge plots

We developed a way to show the connectivity of an interaction with single-cell resolution. The plot comes with two layers of scatter plot of cells placed at the top and bottom of a 3D box space, for labeling the receivers and senders, respectively. In each layer, we use low transparency to highlight the cells that is sending or receiving the signal of the specified interaction. Cells are colored by cluster at the mean time. Finally, we bring lines that connect the senders with their corresponding tentative receivers, which are the edges. 

```{r plotEdge}
plotEdge(cs, "CPI-SS0D5E30C6C", slot.use = "GauEps-Raw")
```

For the cluster annotation legend, users can simply use `plotCluster()` for reference.

```{r plotCluster}
plotCluster(cs)
```

A panel of edge plot can be added to the significance plot combination with setting `edge = TRUE`. So it is already together with the cluster legend there.

```{r plotSignifEdge, fig.width=14, fig.height=6}
plotSignif2(cs, intr = "CPI-SS0D5E30C6C", slot.use = "GauEps-Raw", return.plot = TRUE,
            edge = TRUE)
```

### Velo plots

The example dataset provided does not have any velocity information available lol.
