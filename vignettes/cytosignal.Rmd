---
title: "Infer cell-cell communication in spatial at single-cell level"
author: "Jialin Liu, Yichen Wang"
date: "2024-01-03"
output: 
  html_document:
    toc: true
    toc_float:
      toc_collapsed: false
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{Infer cell-cell communication at single-cell level}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, results = "hide")
```

## Introduction

CytoSignal detects cell-cell signaling from spatial transcriptomics data at single-cell resolution. CytoSignal performs a nonparametric statistical test to identify which cells within a tissue have significant activity for a particular signaling interaction. CytoSignal considers multi-component interactions and separately models interactions mediated by diffusion vs. contact-dependent molecules.

## Example data

In this tutorial, we demonstrate how to preform CytoSignal on a mouse embryonic E14 brain data captured by Slide-tags, a spatial transcriptomics protocol at single-cell resolution. This data was originally produced in the work of [Andrew J. C. Russell et al., 2023](https://doi.org/10.1101/2023.04.01.535228), and is now publicly available on Single-Cell Portal via [SCP2170](https://singlecell.broadinstitute.org/single_cell/study/SCP2170/slide-tags-snrna-seq-on-mouse-embryonic-e14-brain). For convenience, we have pre-processed the data so it can be easily loaded into user R environment, which is available at [figshare](https://figshare.com/articles/dataset/CytoSignal_example_dataset/24938868). 

- Raw gene expression count matrix: [SCP2170_annotated_dgCMatrix.rds](https://figshare.com/ndownloader/files/43898937), 26,944 genes by 4623 nuclei)
- Corresponding cluster annotation: [SCP2170_cluster.csv](https://figshare.com/ndownloader/files/43898934)
- Spatial location: [SCP2170_spatial.csv](https://figshare.com/ndownloader/files/43898931)


```{r download, include=FALSE}
if (!file.exists("SCP2170_annotated_dgCMatrix.rds")) {
    download.file("https://figshare.com/ndownloader/files/43898937",
                  "SCP2170_annotated_dgCMatrix.rds")
}
if (!file.exists("SCP2170_cluster.csv")) {
    download.file("https://figshare.com/ndownloader/files/43898934",
                  "SCP2170_cluster.csv")
}
if (!file.exists("SCP2170_spatial.csv")) {
    download.file("https://figshare.com/ndownloader/files/43898931",
                  "SCP2170_spatial.csv")
}
```

## Create CytoSignal object

### Loading example data

Download the files listed above from the provided link, into a desired local directory. The code chunk below assumes that users have the files placed at the current working directory (as can be shown by `getwd()`).

Then load the data into R environment. Some preparation needs to be done meanwhile in order to properly load them into a CytoSignal object later. 

```{r load}
## The RDS file will be loaded into a ready-to-use object
dge <- readRDS("SCP2170_annotated_dgCMatrix.rds")

## The cluster annotation need to be presented as a factor object
cluster <- read.csv("SCP2170_cluster.csv")
cluster <- factor(cluster$cell_type)
names(cluster) <- colnames(dge)

## The spatial coordinates need to be presented as a matrix object
spatial <- as.matrix(read.csv("SCP2170_spatial.csv", row.names = 1))
## Please make sure that the dimension names are lower case "x" and "y"
colnames(spatial) <- c("x", "y")
```

Then a CytoSignal object can be created with the following command.

```{r createObj}
library(cytosignal)

cs <- createCytoSignal(raw.data = dge, cells.loc = spatial, clusters = cluster)
```

### Database

CytoSignal has a built-in ligand-receptor interaction database resorted from CellphoneDB, which can be simply loaded into the object running the following command. 

```{r loadDB}
cs <- addIntrDB(cs, g_to_u, db.diff, db.cont, inter.index)
```

## Preprocessing

We remove low-quality cells and genes and also keep only genes available to the interaction database.

```{r qc}
cs <- removeLowQuality(cs, counts.thresh = 300)
cs <- changeUniprot(cs)
```

## Imputation

The basic idea of calculating single-cell resolution interaction scores with spatial information utilized is to infer the amount of ligand $L$ that location $i$ receives using amount of molecules from nearest neighbors (NN) weighted by physical distance. We model the NN finding differently for diffusible ligands and contact-dependent ligands. For diffusible ligands, we use a Gaussian kernel plus Epsilon ball (GauEps) to weight the amount of ligand received by each cell from its neighbors. For contact-dependent ligands, we use Delaunay Triangulation (DT) to find the directly connected neighbors of each cell. 

### Estimate parameters for Gaussian kernel

Before we start, we need to determine the parameters of the Gaussian kernel. For determining the parameters of the kernel, we will need the conversion ratio between the arbitrary units of the spatial coordinates and real unit (such as Âµm), which is based on prior knowledge of user dataset. For the specific example Slide-tags data, the conversion ratio is 0.73. Next, run the following function to determine the parameters.

```{r inferEps}
cs <- inferEpsParams(cs, scale.factor = 0.73)
```

For sanity check, the inferred parameters for the Gaussian kernel can be accessed as shown below.

```{r showSigma, results=TRUE}
cs@parameters$r.diffuse.scale
cs@parameters$sigma.scale
```

### Find nearest neighbors

With the inferred parameters, we can then find the nearest neighbors together with the weights for each neighbor calculated through the corresponding models ("GauEps", "DT").

```{r findNN}
cs <- findNN(cs)
```

### Impute received amount of ligands

With the NN found and weights for each neighbor calculated, we can then impute the received amount of ligands for each cell. Meanwhile, the amount of receptors for each cell is imputed as the raw amount of modulecules expressed in place.

```{r impute}
cs <- imputeLR(cs)
```

## Calculating LR Scores

LR Score is defined for each cell and measures the signaling interaction strength. Generally, we first calculate the LR score with the imputation derived from the previous step, and then we perform the permutation test to calculate the null distribution of the imputed ligands and receptors. Next, we calculate a one-sided p-value for the null hypothesis that the signal strength observed for a particular cell is no larger than expected based on the ligand and receptor expression level within the tissue. To control for multiple hypothesis testing and potential biases caused by cellular density differences, we further perform spatial false discovery rate correction. The output of CytoSignal is a test statistic $S$ and adjusted p-value for each signaling interaction within each cell in the tissue. Finally, cells with significant signaling activity can be identified by setting a significance level such as `p.value = 0.05`.

```{r lrscore}
cs <- inferIntrScore(cs)
```

`reads.thresh` is the minimum number of reads for a ligand-receptor interaction to be considered. `sig.thresh` is the minimum number of beads for a ligand-receptor interaction to be considered. The three thresholds can be changed arbitrarily if the number of the significant beads is too large or too small. 

To view the interactions that are significant, we provide accessor function `showIntr()`. 

The argument `slot.use` is for specifying the LRscore calculation model used. Possible options are explained as followed:

- `"GauEps-Raw"`: Ligand values are imputed with Gaussian Epsilon ball and receptor values are taken from raw expression. Typically for the diffusion-dependent interactions.
- `"DT-Raw"`: Ligand values are imputed with Delaunay Triangulation and receptor values are taken from raw expression. Typically for the contact-dependent interactions.
- `"GauEps-DT"`: Ligand values are imputed with Gaussian Epsilon ball and receptor values are imputed with Delaunay Triangulation. This is for diffusion-dependent interactions, but exists only when `inferIntrScore()` is run with `recep.smooth = TRUE`.
- `"DT-DT"`: Ligand values and receptor values are all imputed with Delaunay Triangulation. This is for contact-dependent interactions, but exists only when `inferIntrScore()` is run with `recep.smooth = TRUE`.

The argument `signif.use` has options and can return interactions that:

- `"result"`: have p-value less that specified threshold.
- `"result.hq"`: have significant p-value and passes the quality control on the minimum number of reads and beads as mentioned above.
- `"result.spx"`: are spatially variable and are of high quality according to that in `"result.hq"`.

Using `return.name = TRUE` here allows showing the unique IDs and interaction name, in a form of "ligand-receptor", at the same time, so things can be more interpretable. 

```{r showIntr, results=TRUE}
showIntr(cs, slot.use = "GauEps-Raw", signif.use = "result.spx", return.name = TRUE)
```

## Visualizing individual interactions

With all the necessary inference performed, now we show the visualization methods for exploring and understanding the analysis. This part shows visualization methods that applies to individual interactions.

Most of the functions shown here understand the interaction specification with two arguments: `intr` and `slot.use`. Users can first show a list of significant interactions that is available for visualization with `showIntr()`. `intr` should then be the unique ID of available interaction(s) and `slot.use` should be a selection as explained above.

### Significance plot

We provide function `plotSignif2()` for making a general combination figure that shows the imputed expression values of the ligand and receptor, the original raw expression values of the ligand and receptor, the inferred LRscore of an interaction of interests, and a cluster label plot. General graphical setting can be found in the documentation of the function (`?plotSignif2`). 

```{r signif, fig.width=9, fig.height=6}
plotSignif2(cs, intr = "CPI-SS0D5E30C6C", slot.use = "GauEps-Raw", return.plot = TRUE)
```

**Recommended:** In a more exploratory scenario, users can also do using numeric index with `intr` and turn to `return.plot = FALSE` (default). This way, a bunch of significance plot of high resolution can be stored on device and be browsed more easily. We also recommend doing this for both contact-dependent interactions and diffusion-dependent interactions.

```{r plotsignif2, eval=FALSE}
# For diffusion dependent interactions
signif.use <- "result.spx"
lrscore.slot <- "GauEps-Raw"
plot_dir <- paste0("path_to_result/diff-dep_", signif.use, "_", lrscore.slot, "/")
plotSignif2(cs, intr = 1:5, slot.use = lrscore.slot, signif.use = signif.use, plot_dir = plot_dir)

# For contact dependent interactions
## Choose a level of significance metric
lrscore.slot <- "DT-Raw"
plot_dir <- paste0("path_to_result/cont-dep_", signif.use, "_", lrscore.slot, "/")
plotSignif2(cs, intr = 1:5, slot.use = lrscore.slot, signif.use = signif.use, plot_dir = plot_dir)
```


### Edge plots

We developed a way to show the connectivity of an interaction with single-cell resolution. The plot comes with two layers of scatter plot of cells placed at the top and bottom of a 3D box space, for labeling the receivers and senders, respectively. In each layer, we use low transparency to highlight the cells that is sending or receiving the signal of the specified interaction. Cells are colored by cluster at the mean time. Finally, we bring lines that connect the senders with their corresponding tentative receivers, which are the edges. 

```{r plotEdge}
plotEdge(cs, "CPI-SS0D5E30C6C", slot.use = "GauEps-Raw")
```

For the cluster annotation legend, users can simply use `plotCluster()` for reference.

```{r plotCluster}
plotCluster(cs)
```

A panel of edge plot can be added to the significance plot combination with setting `edge = TRUE`. So it is already together with the cluster legend there.

```{r plotSignifEdge, fig.width=14, fig.height=6}
plotSignif2(cs, intr = "CPI-SS0D5E30C6C", slot.use = "GauEps-Raw", return.plot = TRUE,
            edge = TRUE)
```

### Velo plots

The example dataset provided does not have any velocity information available lol.
